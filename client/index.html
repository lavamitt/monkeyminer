<!DOCTYPE html>
<html lang="en">
<head>
  <title>monkey miner!</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico"/>
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <canvas id="game"></canvas>
  <script src="monkey.js" type="module"></script>
  <script src="banana.js" type="module"></script>
  <script src="envelope.js" type="module"></script>
  <div id="info">
    Players Online: <span id="playerCount">0</span><br>
    Position: <span id="position">0, 0</span><br>
    ID: <span id='monkeyId'>null</span><br>
    Score: <span id="score">0</span>
  </div>
  <div id="controls">
    Arrow keys to move<br>
    Space to mine the highlighted block<br>
    Q to pick up a highlighted banana<br>
    T to send a chat message<br>
    L to write and place a letter (must be facing empty square)<br>
    R to read highlighted letter<br>
    Bring the needed number of monkeys with bananas<br>
    - to the red zones for a reward!
  </div>
  <div id="topScores">
    Top Scores:<br>
    <span id="scores"></span>
  </div>
  <canvas id="inventorySlot" width="48" height="48"></canvas>
  <input type="text" id="chatInput" placeholder="Press Enter to chat..." maxlength="100">
  <div id="letterUI" style="display: none;">
    <textarea 
      id="letterInput" 
      placeholder="Write your letter here... Press Enter to confirm, Escape to cancel" 
      maxlength="500"
    ></textarea>
  </div>
  <div id="letterReadingUI" style="display: none;">
    <div class="letter-content">
      <div class="letter-header">
        From: <span id="letterAuthor"></span><br>
        Time: <span id="letterTime"></span>
      </div>
      <div id="letterText"></div>
      <button id="closeLetter">Close</button>
    </div>
  </div>

  <script type="module">
    import { drawMonkeySprite } from './monkey.js';
    import { drawBananaSprite } from './banana.js';
    import { drawEnvelopeSprite } from './envelope.js';

    // set up game canvas
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // set up game elements
    const playerCountElement = document.getElementById('playerCount');
    const positionElement = document.getElementById('position');
    const scoreElement = document.getElementById('score');
    const topScoresElement = document.getElementById('scores');
    const monkeyIdElement = document.getElementById('monkeyId');
    const chatInputElement = document.getElementById('chatInput');
    const letterUIElement = document.getElementById('letterUI');
    const letterInputElement = document.getElementById('letterInput');
    const letterReadingUIElement = document.getElementById('letterReadingUI');
    const letterAuthorElement = document.getElementById('letterAuthor');
    const letterTimeElement = document.getElementById('letterTime');
    const letterTextElement = document.getElementById('letterText');
    const closeLetterButton = document.getElementById('closeLetter');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // GAME STATE
    const GRID_SIZE = 32;
    let players = new Map();
    let myId = null;
    let viewportX = 0;
    let viewportY = 0;
    let terrain = [];
    let zones = new Map();
    let messages = new Map();
    let animationFrame = 0;
    let lastAnimationUpdate = 0;
    const ANIMATION_SPEED = 150;
    let lastFrameTime = 0;
    const BASE_SPEED = 360;

    const BLOCK_TYPE = Object.freeze({
      EMPTY: 0,
      DIRT: 1,
      ORE: 2,
      EMPTY_WITH_BANANA: 3,
      EMPTY_WITH_ENVELOPE: 4,
      ZONE: 5
    });

    // TILE PATTERNS
    function createDirtPattern() {
      const dirtPattern = document.createElement('canvas');
      dirtPattern.width = GRID_SIZE;
      dirtPattern.height = GRID_SIZE;
      const dirtPatternCtx = dirtPattern.getContext('2d');

      // Base brown color
      dirtPatternCtx.fillStyle = '#8B6143';
      dirtPatternCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
      
      // Add texture details
      dirtPatternCtx.fillStyle = '#7B5133';
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 2 + Math.random() * 4;
        dirtPatternCtx.fillRect(x, y, size, size);
      }

      // Add some lighter specs
      dirtPatternCtx.fillStyle = '#9B7153';
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 1 + Math.random() * 3;
        dirtPatternCtx.fillRect(x, y, size, size);
      }

      // Add a subtle grid line
      dirtPatternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      dirtPatternCtx.strokeRect(0, 0, GRID_SIZE, GRID_SIZE);

      return ctx.createPattern(dirtPattern, 'repeat')
    }

    function createOrePattern() {
      const orePattern = document.createElement('canvas');
      orePattern.width = GRID_SIZE;
      orePattern.height = GRID_SIZE;
      const orePatternCtx = orePattern.getContext('2d');

      // Base grey color
      orePatternCtx.fillStyle = '#9AA7AD';
      orePatternCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
      
      // Add texture details
      orePatternCtx.fillStyle = '#818594';
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 2 + Math.random() * 4;
        orePatternCtx.fillRect(x, y, size, size);
      }

      // Add some lighter specs
      orePatternCtx.fillStyle = '#B0C4D4';
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 1 + Math.random() * 3;
        orePatternCtx.fillRect(x, y, size, size);
      }

      // Add a subtle grid line
      orePatternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      orePatternCtx.strokeRect(0, 0, GRID_SIZE, GRID_SIZE);

      return ctx.createPattern(orePattern, 'repeat');
    }

    // Create patterns for each block type
    const patterns = {
        [BLOCK_TYPE.DIRT]: createDirtPattern(),
        [BLOCK_TYPE.ORE]: createOrePattern(),
    };

    const ANIMATION_FRAMES = 8;  // Number of frames in the animation
    const zonePatternCache = {
        completed: new Array(ANIMATION_FRAMES),
        incomplete: new Array(ANIMATION_FRAMES)
    };

    function createZonePatterns() {
      // Create patterns for each animation frame
      for (let frame = 0; frame < ANIMATION_FRAMES; frame++) {
        // Create completed pattern
        const completedCanvas = document.createElement('canvas');
        completedCanvas.width = GRID_SIZE;
        completedCanvas.height = GRID_SIZE;
        const completedCtx = completedCanvas.getContext('2d');
        
        // Base color and lines (static part)
        completedCtx.fillStyle = '#2eb82e';
        completedCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
        completedCtx.strokeStyle = '#1a661a';
        completedCtx.lineWidth = 1;
        
        completedCtx.beginPath();
        completedCtx.moveTo(0, GRID_SIZE/2);
        completedCtx.quadraticCurveTo(GRID_SIZE/2, 0, GRID_SIZE, GRID_SIZE/2);
        completedCtx.stroke();
        
        completedCtx.beginPath();
        completedCtx.moveTo(GRID_SIZE/2, 0);
        completedCtx.quadraticCurveTo(GRID_SIZE, GRID_SIZE/2, GRID_SIZE/2, GRID_SIZE);
        completedCtx.stroke();
        
        // Animated sparkles
        completedCtx.fillStyle = '#4dff4d';
        // Use frame number to offset sparkle positions
        for (let i = 0; i < 4; i++) {
            const angle = (frame / ANIMATION_FRAMES * Math.PI * 2) + (i * Math.PI / 2);
            const radius = GRID_SIZE / 4;
            const x = GRID_SIZE/2 + Math.cos(angle) * radius;
            const y = GRID_SIZE/2 + Math.sin(angle) * radius;
            completedCtx.beginPath();
            completedCtx.arc(x, y, 2, 0, Math.PI * 2);
            completedCtx.fill();
        }
        
        // Create incomplete pattern
        const incompleteCanvas = document.createElement('canvas');
        incompleteCanvas.width = GRID_SIZE;
        incompleteCanvas.height = GRID_SIZE;
        const incompleteCtx = incompleteCanvas.getContext('2d');
        
        // Base color and lines (static part)
        incompleteCtx.fillStyle = '#cc3300';
        incompleteCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
        incompleteCtx.strokeStyle = '#801a00';
        incompleteCtx.lineWidth = 1;
        
        incompleteCtx.beginPath();
        incompleteCtx.moveTo(0, GRID_SIZE/2);
        incompleteCtx.quadraticCurveTo(GRID_SIZE/2, 0, GRID_SIZE, GRID_SIZE/2);
        incompleteCtx.stroke();
        
        incompleteCtx.beginPath();
        incompleteCtx.moveTo(GRID_SIZE/2, 0);
        incompleteCtx.quadraticCurveTo(GRID_SIZE, GRID_SIZE/2, GRID_SIZE/2, GRID_SIZE);
        incompleteCtx.stroke();
        
        // Animated sparkles
        incompleteCtx.fillStyle = '#ff6666';
        for (let i = 0; i < 4; i++) {
            const angle = (frame / ANIMATION_FRAMES * Math.PI * 2) + (i * Math.PI / 2);
            const radius = GRID_SIZE / 4;
            const x = GRID_SIZE/2 + Math.cos(angle) * radius;
            const y = GRID_SIZE/2 + Math.sin(angle) * radius;
            incompleteCtx.beginPath();
            incompleteCtx.arc(x, y, 2, 0, Math.PI * 2);
            incompleteCtx.fill();
        }
        
        // Cache the patterns
        zonePatternCache.completed[frame] = ctx.createPattern(completedCanvas, 'repeat');
        zonePatternCache.incomplete[frame] = ctx.createPattern(incompleteCanvas, 'repeat');
      }
    }

    let lastZoneAnimationUpdate = 0;
    let currentZoneFrame = 0;
    const ZONE_ANIMATION_SPEED = 100;

    createZonePatterns();

    function drawChatBubble(ctx, x, y, message) {
      const padding = 8;
      const borderRadius = 8;
      
      // Measure text for bubble size
      ctx.font = '14px monospace';
      const textMetrics = ctx.measureText(message);
      const textWidth = textMetrics.width;
      const textHeight = 14; // Approximate height for monospace font
      
      // Bubble dimensions
      const bubbleWidth = textWidth + (padding * 2);
      const bubbleHeight = textHeight + (padding * 2);
      const triangleHeight = 8;
      
      // Position bubble above monkey
      const bubbleX = x - (bubbleWidth / 2);
      const bubbleY = y - bubbleHeight - GRID_SIZE - triangleHeight;
      
      // Draw bubble background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.beginPath();
      // Draw rounded rectangle
      ctx.moveTo(bubbleX + borderRadius, bubbleY);
      ctx.lineTo(bubbleX + bubbleWidth - borderRadius, bubbleY);
      ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + borderRadius);
      ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - borderRadius);
      ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - borderRadius, bubbleY + bubbleHeight);
      ctx.lineTo(bubbleX + borderRadius, bubbleY + bubbleHeight);
      ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - borderRadius);
      ctx.lineTo(bubbleX, bubbleY + borderRadius);
      ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + borderRadius, bubbleY);
      ctx.closePath();
      ctx.fill();
      
      // Draw triangle
      ctx.beginPath();
      ctx.moveTo(x - 8, bubbleY + bubbleHeight);
      ctx.lineTo(x + 8, bubbleY + bubbleHeight);
      ctx.lineTo(x, bubbleY + bubbleHeight + triangleHeight);
      ctx.closePath();
      ctx.fill();
      
      // Draw text
      ctx.fillStyle = 'white';
      ctx.fillText(message, bubbleX + padding, bubbleY + padding + textHeight);
  }

    // SET UP WEBSOCKET
    // 13.59.50.220
    const ws = new WebSocket('ws://13.59.50.220:3000');

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      switch (data.type) {
        case 'init':
          myId = data.id;
          terrain = data.terrain;
          data.zones.forEach(zone => {
            zones.set(zone.key, zone)
          })
          data.players.forEach(player => {
            players.set(player.id, player);
          });
          const myPlayer = players.get(myId);
          if (myPlayer) {
            viewportX = myPlayer.x - canvas.width / 2;
            viewportY = myPlayer.y - canvas.height / 2;
          }
          data.messages.forEach(msg => {
            messages.set(msg.key, {
              message: msg.message,
              expiration: msg.expiration
            })
          })
          monkeyIdElement.textContent = "monkey_" + myPlayer.id;
          break;

        case 'playerJoin':
          players.set(data.id, data.player);
          break;

        case 'playerMove':
          if (players.has(data.id) && data.id !== myId) {
            const player = players.get(data.id);
            player.x = data.x;
            player.y = data.y;
            player.direction = data.direction;
            player.moving = data.moving;
          }
          break;

        case 'scoreUpdate':
          players.get(data.id).score = data.value
          break;

        case 'playerLeave':
          players.delete(data.id);
          break;
        
        case 'inventoryUpdate':
          players.get(data.id).inventory = data.value;
          break;

        case 'terrainUpdate':
          terrain[data.y][data.x] = data.value;
          break;

        case 'zoneUpdate':
          zones.set(data.key, data.zone);
          break;

        case 'chatUpdate':
          messages.set(data.id, {
            message: data.message,
            expiration: data.expiration
          })
          break;

        case 'letterToRead':
          const author = players.get(data.authorId);
          letterAuthorElement.textContent = author ? `monkey_${data.authorId}` : 'Unknown Monkey';
          letterTimeElement.textContent = new Date(data.timestamp).toLocaleString();
          letterTextElement.textContent = data.message;
          letterReadingUIElement.style.display = 'block';
          break;
      }
    };

    function getTargetBlock(player) {
      const playerBlockX = Math.floor(player.x / GRID_SIZE);
      const playerBlockY = Math.floor(player.y / GRID_SIZE);
      
      switch(player.direction) {
        case 'left':
          return { x: playerBlockX - 1, y: playerBlockY };
        case 'right':
          return { x: playerBlockX + 1, y: playerBlockY };
        case 'up':
          return { x: playerBlockX, y: playerBlockY - 1 };
        case 'down':
          return { x: playerBlockX, y: playerBlockY + 1 };
      }
    }

    // Handle keyboard input
    closeLetterButton.addEventListener('click', () => {
      letterReadingUIElement.style.display = 'none';
    });

    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      keys.add(e.key);
      if (e.key === ' ' && document.activeElement !== chatInputElement && document.activeElement !== letterInputElement) { // Space bar to mine
        const myPlayer = players.get(myId);
        if (myPlayer) {
          const targetBlock = getTargetBlock(myPlayer);
          ws.send(JSON.stringify({
            type: 'mine',
            blockX: targetBlock.x,
            blockY: targetBlock.y
          }));
        }
      }

      if (e.key === "q" && document.activeElement !== chatInputElement && document.activeElement !== letterInputElement) {
        const myPlayer = players.get(myId);
        if (myPlayer) {
          const targetBlock = getTargetBlock(myPlayer);
          ws.send(JSON.stringify({
            type: 'pickup',
            blockX: targetBlock.x,
            blockY: targetBlock.y
          }));
        }
      }

      if (e.key === "r" && letterReadingUIElement.style.display !== "block" && document.activeElement !== chatInputElement && document.activeElement !== letterInputElement) {
        const myPlayer = players.get(myId);
        if (myPlayer) {
          const targetBlock = getTargetBlock(myPlayer);
          ws.send(JSON.stringify({
            type: 'read',
            blockX: targetBlock.x,
            blockY: targetBlock.y
          }));
        }
      }

      if (e.key === "t" && document.activeElement !== chatInputElement && document.activeElement !== letterInputElement) {
        e.preventDefault();
        chatInputElement.style.display = "block";
        chatInputElement.focus();
        keys.delete(e.key);
      }

      if (e.key === "Enter" && document.activeElement === chatInputElement) {
        const message = chatInputElement.value;
        chatInputElement.style.display = "none";
        if (message) {
          // Send message to server
          ws.send(JSON.stringify({
            type: 'chat',
            id: myId,
            message,
          }));
          chatInputElement.value = "";
        }
      }

      if (e.key === "l" && document.activeElement !== letterInputElement && document.activeElement !== chatInputElement) {
        e.preventDefault();
        const myPlayer = players.get(myId);
        if (myPlayer) {
          const targetBlock = getTargetBlock(myPlayer);
          // Only allow placing letters on empty spaces
          if (terrain[targetBlock.y]?.[targetBlock.x] === BLOCK_TYPE.EMPTY) {
            letterUIElement.style.display = "block";
            letterInputElement.focus();
          }
        }
      }

      if (e.key === "Enter" && !e.shiftKey && document.activeElement === letterInputElement) {
        e.preventDefault();
        const letter = letterInputElement.value;
        if (letter) {
          const myPlayer = players.get(myId);
          const targetBlock = getTargetBlock(myPlayer);
          
          // Send letter to server
          ws.send(JSON.stringify({
            type: 'placeLetter',
            message: letter,
            blockX: targetBlock.x,
            blockY: targetBlock.y
          }));
        }
        letterInputElement.value = "";
        letterUIElement.style.display = "none";
      }

      if (e.key === "Escape" && document.activeElement === letterInputElement) {
        letterInputElement.value = "";
        letterUIElement.style.display = "none";
      }
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key));

    function gameLoop(timestamp) {
      const deltaTime = (timestamp - lastFrameTime) / 1000;
      lastFrameTime = timestamp;

      if (timestamp - lastAnimationUpdate > ANIMATION_SPEED) {
        animationFrame = (animationFrame + 1) % 2;
        lastAnimationUpdate = timestamp;
      }

      if (timestamp - lastZoneAnimationUpdate > ZONE_ANIMATION_SPEED) {
        currentZoneFrame = (currentZoneFrame + 1) % ANIMATION_FRAMES;
        lastZoneAnimationUpdate = timestamp;
      }

      const myPlayer = players.get(myId);
      if (myPlayer) {
        const speed = BASE_SPEED * deltaTime;
        let newX = myPlayer.x;
        let newY = myPlayer.y;
        let moved = false;
        let newDirection = myPlayer.direction;
        
        if (keys.has('ArrowLeft')) {
          newX -= speed;
          newDirection = 'left';
        }
        if (keys.has('ArrowRight')) {
          newX += speed;
          newDirection = 'right';
        }
        if (keys.has('ArrowUp')) {
          newY -= speed;
          newDirection = 'up';
        }
        if (keys.has('ArrowDown')) {
          newY += speed;
          newDirection = 'down';
        }

        // Check collision with terrain
        const blockX = Math.floor(newX / GRID_SIZE);
        const blockY = Math.floor(newY / GRID_SIZE);
        
        if (terrain[blockY]?.[blockX] == BLOCK_TYPE.EMPTY || terrain[blockY]?.[blockX] == BLOCK_TYPE.EMPTY_WITH_BANANA || terrain[blockY]?.[blockX] == BLOCK_TYPE.ZONE) {
          moved = newX !== myPlayer.x || newY !== myPlayer.y;
          myPlayer.x = newX;
          myPlayer.y = newY;
        }

        // Always update direction, even if movement is blocked
        if (newDirection !== myPlayer.direction || moved) {
          myPlayer.direction = newDirection;
          myPlayer.moving = moved;
          ws.send(JSON.stringify({
            type: 'move',
            x: myPlayer.x,
            y: myPlayer.y,
            direction: myPlayer.direction,
            moving: myPlayer.moving
          }));

          viewportX = myPlayer.x - canvas.width / 2;
          viewportY = myPlayer.y - canvas.height / 2;
        }

        myPlayer.moving = moved;

        positionElement.textContent = `${Math.floor(myPlayer.x / GRID_SIZE)}, ${Math.floor(myPlayer.y / GRID_SIZE)}`;
      }

      // Clear canvas
      ctx.fillStyle = '#B89D81';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw terrain
      const startBlockX = Math.floor(viewportX / GRID_SIZE);
      const startBlockY = Math.floor(viewportY / GRID_SIZE);
      const endBlockX = startBlockX + Math.ceil(canvas.width / GRID_SIZE) + 1;
      const endBlockY = startBlockY + Math.ceil(canvas.height / GRID_SIZE) + 1;

      for (let y = startBlockY; y < endBlockY; y++) {
        for (let x = startBlockX; x < endBlockX; x++) {
          let block = terrain[y]?.[x];
          if (block !== BLOCK_TYPE.EMPTY) {
            const screenX = x * GRID_SIZE - viewportX;
            const screenY = y * GRID_SIZE - viewportY;

            if (block === BLOCK_TYPE.ZONE) {
                // Find which zone this block belongs to
                for (let [coords, zone] of zones) {
                    const [zx, zy] = coords.split(',').map(Number);
                    if (x >= zx && x < zx + zone.width && 
                        y >= zy && y < zy + zone.height) {
                        // Draw zone pattern
                        ctx.fillStyle = zone.completed ? 
                          zonePatternCache.completed[currentZoneFrame] : 
                          zonePatternCache.incomplete[currentZoneFrame];
                        ctx.fillRect(screenX, screenY, GRID_SIZE, GRID_SIZE);
                        
                        // If this is the center block of the zone, draw the requirement text
                        const centerX = Math.floor(zx + zone.width/2) === x;
                        const centerY = Math.floor(zy + zone.height/2) === y;
                        if (centerX && centerY && !zone.completed) {
                            // Draw requirement text
                            ctx.save();
                            ctx.fillStyle = 'white';
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 3;
                            ctx.font = 'bold 20px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const text = `${zone.currentMonkeys.length}/${zone.requiredMonkeys}`;
                            const textX = screenX + GRID_SIZE/2;
                            const textY = screenY + GRID_SIZE/2;
                            // Draw text stroke
                            ctx.strokeText(text, textX, textY);
                            // Draw text fill
                            ctx.fillText(text, textX, textY);
                            ctx.restore();
                        }
                        break;
                    }
                }
            } else if (block === BLOCK_TYPE.EMPTY_WITH_BANANA) {
              drawBananaSprite(ctx, screenX, screenY);
            } else if (block === BLOCK_TYPE.EMPTY_WITH_ENVELOPE) {
              drawEnvelopeSprite(ctx, screenX, screenY);
            } else {
              // Get pattern based on block type
              const pattern = patterns[block];
              if (pattern) {
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.fillStyle = pattern;
                ctx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
                ctx.restore();
              }
            }
         }
        }
      }

      // Draw mining target indicator for current player
      if (myPlayer) {
        const targetBlock = getTargetBlock(myPlayer);
        if (terrain[targetBlock.y]?.[targetBlock.x] !== BLOCK_TYPE.EMPTY) {
          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
          ctx.fillRect(
            targetBlock.x * GRID_SIZE - viewportX,
            targetBlock.y * GRID_SIZE - viewportY,
            GRID_SIZE,
            GRID_SIZE
          );
        }
      }

      // Draw players
      players.forEach((player, id) => {
        const screenX = player.x - viewportX - GRID_SIZE/2;
        const screenY = player.y - viewportY - GRID_SIZE/2;
        
        // Only animate if player is moving
        const frame = player.moving ? animationFrame : 0;
        drawMonkeySprite(ctx, screenX, screenY, player.color, player.direction, frame);
        
        // Draw outline for current player
        if (id === myId) {
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.strokeRect(screenX, screenY, GRID_SIZE, GRID_SIZE);
        }
      });

      const currentTime = Date.now()
      messages.forEach((msg, id) => {
        if (msg.expiration < currentTime) {
          messages.delete(id);
        } else {
          const player = players.get(id);
          if (player) {
            const screenX = player.x - viewportX;
            const screenY = player.y - viewportY;
            drawChatBubble(ctx, screenX, screenY, msg.message)
          }
        }
      })

      const inventoryCanvas = document.getElementById('inventorySlot');
      const inventoryCtx = inventoryCanvas.getContext('2d');

      inventoryCtx.clearRect(0, 0, 48, 48);
      inventoryCtx.fillStyle = 'rgba(68, 68, 68, 0.4)';
      inventoryCtx.fillRect(0, 0, 48, 48);
      inventoryCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      inventoryCtx.strokeRect(0, 0, 48, 48);

      if (myPlayer && myPlayer.inventory.length > 0) {
          drawBananaSprite(inventoryCtx, 8, 8);

          inventoryCtx.fillStyle = 'white'; 
          inventoryCtx.font = '16px Arial';
          inventoryCtx.textBaseline = 'bottom';
          inventoryCtx.textAlign = 'right';
    
          inventoryCtx.fillText(
            myPlayer.inventory.length.toString(),
            44,  // X position (48 - 4 for padding)
            44   // Y position (48 - 4 for padding)
          );
      }

      playerCountElement.textContent = players.size;
      if (myPlayer) {
        scoreElement.textContent = myPlayer.score;
      }
      const current_players = Array.from(players.values());
      current_players.sort((a, b) => b.score - a.score);
      topScoresElement.innerHTML = current_players.map((player) => "monkey_" + player.id + ": " + player.score).join('<br>');

      requestAnimationFrame(gameLoop);
    }

    lastFrameTime = performance.now();
    gameLoop();
  </script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <title>Multiplayer Mining Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #1a1a1a;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #controls {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script src="monkey.js" type="module"></script>
  <div id="info">
    Players Online: <span id="playerCount">0</span><br>
    Position: <span id="position">0, 0</span>
  </div>
  <div id="controls">
    Arrow keys to move<br>
    Space to mine the highlighted block
  </div>

  <script type="module">
    import { drawMonkeySprite } from './monkey.js';
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const playerCountElement = document.getElementById('playerCount');
    const positionElement = document.getElementById('position');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game state
    const GRID_SIZE = 32;
    let players = new Map();
    let myId = null;
    let viewportX = 0;
    let viewportY = 0;
    let terrain = [];
    let animationFrame = 0;
    let lastAnimationUpdate = 0;
    const ANIMATION_SPEED = 150;

    const BLOCK_TYPE = Object.freeze({
      EMPTY: 0,
      DIRT: 1,
      ORE: 2,
    });

    const dirtPattern = document.createElement('canvas');
    dirtPattern.width = GRID_SIZE;
    dirtPattern.height = GRID_SIZE;
    const dirtPatternCtx = dirtPattern.getContext('2d');

    function createDirtTexture() {
      // Base brown color
      dirtPatternCtx.fillStyle = '#8B6143';
      dirtPatternCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
      
      // Add texture details
      dirtPatternCtx.fillStyle = '#7B5133';
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 2 + Math.random() * 4;
        dirtPatternCtx.fillRect(x, y, size, size);
      }

      // Add some lighter specs
      dirtPatternCtx.fillStyle = '#9B7153';
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 1 + Math.random() * 3;
        dirtPatternCtx.fillRect(x, y, size, size);
      }

      // Add a subtle grid line
      dirtPatternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      dirtPatternCtx.strokeRect(0, 0, GRID_SIZE, GRID_SIZE);
    }
    createDirtTexture();

    const orePattern = document.createElement('canvas');
    orePattern.width = GRID_SIZE;
    orePattern.height = GRID_SIZE;
    const orePatternCtx = orePattern.getContext('2d');

    function createOreTexture() {
      // Base grey color
      orePatternCtx.fillStyle = '#9AA7AD';
      orePatternCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
      
      // Add texture details
      orePatternCtx.fillStyle = '#818594';
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 2 + Math.random() * 4;
        orePatternCtx.fillRect(x, y, size, size);
      }

      // Add some lighter specs
      orePatternCtx.fillStyle = '#B0C4D4';
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 1 + Math.random() * 3;
        orePatternCtx.fillRect(x, y, size, size);
      }

      // Add a subtle grid line
      orePatternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      orePatternCtx.strokeRect(0, 0, GRID_SIZE, GRID_SIZE);
    }
    createOreTexture();

    const ws = new WebSocket('ws://localhost:3000');

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      switch (data.type) {
        case 'init':
          myId = data.id;
          terrain = data.terrain;
          data.players.forEach(player => {
            players.set(player.id, player);
          });
          const myPlayer = players.get(myId);
          if (myPlayer) {
            viewportX = myPlayer.x - canvas.width / 2;
            viewportY = myPlayer.y - canvas.height / 2;
          }
          break;

        case 'playerJoin':
          players.set(data.id, {
            x: data.x,
            y: data.y,
            color: data.color,
            direction: data.direction
          });
          break;

        case 'playerMove':
          if (players.has(data.id)) {
            const player = players.get(data.id);
            player.x = data.x;
            player.y = data.y;
            player.direction = data.direction;
            player.moving = data.moving;
          }
          break;

        case 'playerLeave':
          players.delete(data.id);
          break;

        case 'terrainUpdate':
          terrain[data.y][data.x] = data.value;
          break;
      }
    };

    function getTargetBlock(player) {
      const playerBlockX = Math.floor(player.x / GRID_SIZE);
      const playerBlockY = Math.floor(player.y / GRID_SIZE);
      
      switch(player.direction) {
        case 'left':
          return { x: playerBlockX - 1, y: playerBlockY };
        case 'right':
          return { x: playerBlockX + 1, y: playerBlockY };
        case 'up':
          return { x: playerBlockX, y: playerBlockY - 1 };
        case 'down':
          return { x: playerBlockX, y: playerBlockY + 1 };
      }
    }

    // Handle keyboard input
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      keys.add(e.key);
      if (e.key === ' ') { // Space bar to mine
        const myPlayer = players.get(myId);
        if (myPlayer) {
          const targetBlock = getTargetBlock(myPlayer);
          ws.send(JSON.stringify({
            type: 'mine',
            blockX: targetBlock.x,
            blockY: targetBlock.y
          }));
        }
      }
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key));

    function gameLoop(timestamp) {
    // Update animation frame
      if (timestamp - lastAnimationUpdate > ANIMATION_SPEED) {
        animationFrame = (animationFrame + 1) % 2;
        lastAnimationUpdate = timestamp;
      }

      const myPlayer = players.get(myId);
      if (myPlayer) {
        const speed = 4;
        let newX = myPlayer.x;
        let newY = myPlayer.y;
        let moved = false;
        let newDirection = myPlayer.direction;
        
        if (keys.has('ArrowLeft')) {
          newX -= speed;
          newDirection = 'left';
        }
        if (keys.has('ArrowRight')) {
          newX += speed;
          newDirection = 'right';
        }
        if (keys.has('ArrowUp')) {
          newY -= speed;
          newDirection = 'up';
        }
        if (keys.has('ArrowDown')) {
          newY += speed;
          newDirection = 'down';
        }

        // Check collision with terrain
        const blockX = Math.floor(newX / GRID_SIZE);
        const blockY = Math.floor(newY / GRID_SIZE);
        
        if (terrain[blockY]?.[blockX] == BLOCK_TYPE.EMPTY) {
          moved = newX !== myPlayer.x || newY !== myPlayer.y;
          myPlayer.x = newX;
          myPlayer.y = newY;
        }

        // Always update direction, even if movement is blocked
        if (newDirection !== myPlayer.direction || moved) {
          myPlayer.direction = newDirection;
          myPlayer.moving = moved;
          ws.send(JSON.stringify({
            type: 'move',
            x: myPlayer.x,
            y: myPlayer.y,
            direction: myPlayer.direction,
            moving: myPlayer.moving
          }));

          viewportX = myPlayer.x - canvas.width / 2;
          viewportY = myPlayer.y - canvas.height / 2;
        }

        positionElement.textContent = `${Math.floor(myPlayer.x / GRID_SIZE)}, ${Math.floor(myPlayer.y / GRID_SIZE)}`;
      }

      // Clear canvas
      ctx.fillStyle = '#B89D81';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw terrain
      const startBlockX = Math.floor(viewportX / GRID_SIZE);
      const startBlockY = Math.floor(viewportY / GRID_SIZE);
      const endBlockX = startBlockX + Math.ceil(canvas.width / GRID_SIZE) + 1;
      const endBlockY = startBlockY + Math.ceil(canvas.height / GRID_SIZE) + 1;

      // Create patterns for each block type
      const patterns = {
        [BLOCK_TYPE.DIRT]: ctx.createPattern(dirtPattern, 'repeat'),
        [BLOCK_TYPE.ORE]: ctx.createPattern(orePattern, 'repeat')
      };

      for (let y = startBlockY; y < endBlockY; y++) {
        for (let x = startBlockX; x < endBlockX; x++) {
          let block = terrain[y]?.[x];

          if (block !== BLOCK_TYPE.EMPTY) {
            const screenX = x * GRID_SIZE - viewportX;
            const screenY = y * GRID_SIZE - viewportY;
        
            // Get pattern based on block type
           const pattern = patterns[block];
           if (pattern) {
             ctx.save();
             ctx.translate(screenX, screenY);
             ctx.fillStyle = pattern;
             ctx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
             ctx.restore();
           }
         }
        }
      }

      // Draw mining target indicator for current player
      if (myPlayer) {
        const targetBlock = getTargetBlock(myPlayer);
        if (terrain[targetBlock.y]?.[targetBlock.x] !== BLOCK_TYPE.EMPTY) {
          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
          ctx.fillRect(
            targetBlock.x * GRID_SIZE - viewportX,
            targetBlock.y * GRID_SIZE - viewportY,
            GRID_SIZE,
            GRID_SIZE
          );
        }
      }

      // Draw players
      players.forEach((player, id) => {
        const screenX = player.x - viewportX - GRID_SIZE/2;
        const screenY = player.y - viewportY - GRID_SIZE/2;
        
        // Only animate if player is moving
        const frame = player.moving ? animationFrame : 0;
        drawMonkeySprite(ctx, screenX, screenY, player.color, player.direction, frame); // player.color, player.direction, frame
        
        // Draw outline for current player
        if (id === myId) {
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.strokeRect(screenX, screenY, GRID_SIZE, GRID_SIZE);
        }
      });

      playerCountElement.textContent = players.size;

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
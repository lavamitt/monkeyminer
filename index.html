<!DOCTYPE html>
<html>
<head>
  <title>Multiplayer Mining Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #1a1a1a;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #controls {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="info">
    Players Online: <span id="playerCount">0</span><br>
    Position: <span id="position">0, 0</span>
  </div>
  <div id="controls">
    Arrow keys to move<br>
    Space to mine the highlighted block
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const playerCountElement = document.getElementById('playerCount');
    const positionElement = document.getElementById('position');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game state
    const GRID_SIZE = 32;
    let players = new Map();
    let myId = null;
    let viewportX = 0;
    let viewportY = 0;
    let terrain = [];
    let animationFrame = 0;
    let lastAnimationUpdate = 0;
    const ANIMATION_SPEED = 150;

    const dirtPattern = document.createElement('canvas');
    dirtPattern.width = GRID_SIZE;
    dirtPattern.height = GRID_SIZE;
    const patternCtx = dirtPattern.getContext('2d');

    function createDirtTexture() {
      // Base brown color
      patternCtx.fillStyle = '#8B6143';
      patternCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
      
      // Add texture details
      patternCtx.fillStyle = '#7B5133';
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 2 + Math.random() * 4;
        patternCtx.fillRect(x, y, size, size);
      }

      // Add some lighter specs
      patternCtx.fillStyle = '#9B7153';
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 1 + Math.random() * 3;
        patternCtx.fillRect(x, y, size, size);
      }

      // Add a subtle grid line
      patternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      patternCtx.strokeRect(0, 0, GRID_SIZE, GRID_SIZE);
    }
    createDirtTexture();

    // function drawMinerSprite(ctx, x, y, color, direction, frame) {
    //   // Body
    //   ctx.fillStyle = color;
    //   ctx.fillRect(x + 8, y + 8, 16, 16);
      
    //   // Helmet
    //   ctx.fillStyle = '#333';
    //   ctx.fillRect(x + 6, y + 4, 20, 8);
      
    //   // Lamp on helmet
    //   ctx.fillStyle = '#FFD700';
    //   if (direction === 'left') ctx.fillRect(x + 6, y + 6, 4, 4);
    //   if (direction === 'right') ctx.fillRect(x + 22, y + 6, 4, 4);
    //   if (direction === 'up') ctx.fillRect(x + 14, y + 4, 4, 4);
    //   if (direction === 'down') ctx.fillRect(x + 14, y + 8, 4, 4);
      
    //   // Legs - animate based on frame
    //   ctx.fillStyle = '#444';
    //   if (frame === 0) {
    //     ctx.fillRect(x + 10, y + 24, 4, 8);
    //     ctx.fillRect(x + 18, y + 24, 4, 8);
    //   } else {
    //     ctx.fillRect(x + 12, y + 24, 4, 8);
    //     ctx.fillRect(x + 16, y + 24, 4, 8);
    //   }
      
    //   // Pickaxe
    //   ctx.strokeStyle = '#666';
    //   ctx.lineWidth = 2;
    //   ctx.beginPath();
    //   switch(direction) {
    //     case 'right':
    //       ctx.moveTo(x + 24, y + 16);
    //       ctx.lineTo(x + 30, y + 12);
    //       ctx.lineTo(x + 28, y + 8);
    //       break;
    //     case 'left':
    //       ctx.moveTo(x + 8, y + 16);
    //       ctx.lineTo(x + 2, y + 12);
    //       ctx.lineTo(x + 4, y + 8);
    //       break;
    //     case 'down':
    //       ctx.moveTo(x + 16, y + 24);
    //       ctx.lineTo(x + 20, y + 30);
    //       ctx.lineTo(x + 24, y + 28);
    //       break;
    //     case 'up':
    //       ctx.moveTo(x + 16, y + 8);
    //       ctx.lineTo(x + 20, y + 2);
    //       ctx.lineTo(x + 24, y + 4);
    //       break;
    //   }
    //   ctx.stroke();
    // }

    // function drawMoleSprite(ctx, x, y, color, direction, frame) {
    //     // Body
    //     ctx.fillStyle = color;
    //     ctx.beginPath();
    //     ctx.ellipse(x + 16, y + 20, 12, 10, 0, 0, Math.PI * 2);
    //     ctx.fill();

    //     // Head
    //     ctx.beginPath();
    //     ctx.ellipse(x + 16, y + 12, 10, 8, 0, 0, Math.PI * 2);
    //     ctx.fill();

    //     // Eyes
    //     ctx.fillStyle = 'black';
    //     ctx.beginPath();
    //     ctx.ellipse(x + 13, y + 10, 2, 2, 0, 0, Math.PI * 2);
    //     ctx.ellipse(x + 19, y + 10, 2, 2, 0, 0, Math.PI * 2);
    //     ctx.fill();

    //     // Nose
    //     ctx.fillStyle = 'pink';
    //     ctx.beginPath();
    //     ctx.ellipse(x + 16, y + 14, 3, 2, 0, 0, Math.PI * 2);
    //     ctx.fill();

    //     // Paws - animate based on frame
    //     ctx.fillStyle = color;
    //     if (frame === 0) {
    //         ctx.fillRect(x + 8, y + 28, 6, 4);
    //         ctx.fillRect(x + 18, y + 28, 6, 4);
    //     } else {
    //         ctx.fillRect(x + 10, y + 26, 6, 4);
    //         ctx.fillRect(x + 16, y + 26, 6, 4);
    //     }

    //     // Direction indicator (e.g., a slightly raised paw)
    //     ctx.beginPath();
    //     switch(direction) {
    //         case 'right':
    //         ctx.ellipse(x + 26, y + 22, 4, 3, 0, 0, Math.PI * 2);
    //         break;
    //         case 'left':
    //         ctx.ellipse(x + 6, y + 22, 4, 3, 0, 0, Math.PI * 2);
    //         break;
    //         case 'down':
    //         ctx.ellipse(x + 16, y + 32, 4, 3, 0, 0, Math.PI * 2);
    //         break;
    //         case 'up':
    //         ctx.ellipse(x + 16, y + 2, 4, 3, 0, 0, Math.PI * 2);
    //         break;
    //     }
    //     ctx.fill();
    //     }


    // Define the pixel art as a 2D array
const monkeySprite = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0],
    [0,0,0,1,1,1,1,2,2,2,3,3,3,3,3,2,2,2,2,2,2,3,3,3,3,1,1,1,0,0,0,0],
    [0,0,1,3,3,3,2,2,2,3,3,3,3,3,3,3,2,2,2,2,3,3,3,3,3,1,3,3,1,0,0,0],
    [0,0,1,3,3,3,2,2,2,3,3,3,1,3,3,3,3,3,3,3,3,3,1,3,3,1,3,3,1,0,0,0],
    [0,0,1,3,3,3,2,2,2,3,3,3,1,3,3,3,3,3,3,3,3,3,1,3,3,1,3,3,1,0,0,0],
    [0,0,0,1,1,1,2,2,2,3,3,3,3,3,3,3,1,1,1,3,3,3,3,3,3,1,1,1,0,0,0,0],
    [0,0,0,0,0,0,1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,1,1,5,5,5,5,5,5,5,5,1,1,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,1,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,0,0,1,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,1,2,5,2,3,3,3,3,3,3,3,3,2,5,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,1,2,2,5,3,3,3,3,3,3,3,3,3,3,5,2,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,1,0,0,1,2,2,5,3,3,3,3,3,3,3,3,3,3,5,2,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,1,1,1,2,2,5,3,3,3,3,3,3,3,3,3,3,5,2,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,1,2,3,3,3,3,3,3,3,3,3,3,1,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,2,2,3,3,3,3,3,3,3,3,2,1,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,2,2,1,1,1,1,1,1,1,2,2,1,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
];


    function darkenColor(hex, percent) {
        // Remove the # if present
        hex = hex.replace(/^#/, '');
        
        // Parse the hex string
        let r = parseInt(hex.slice(0, 2), 16);
        let g = parseInt(hex.slice(2, 4), 16);
        let b = parseInt(hex.slice(4, 6), 16);

        // Darken the color
        r = Math.floor(r * (1 - percent / 100));
        g = Math.floor(g * (1 - percent / 100));
        b = Math.floor(b * (1 - percent / 100));

        // Ensure the values are within 0-255 range
        r = Math.min(255, Math.max(0, r));
        g = Math.min(255, Math.max(0, g));
        b = Math.min(255, Math.max(0, b));

        // Convert back to hex
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    function drawMonkeySprite(ctx, x, y, body_color="#B26B47") {
        // Define the color palette
        const monkeyColors = [
            'transparent',                  // 0: transparent
            '#000000',                      // 1: black (outline)
            body_color,                      // 2: body color, default = #B26B47
            '#E4B86D',                      // 3: ear/belly color
            'unused',                       // whoops, didnt put 4
            darkenColor(body_color, 30)     // 5: darker shading (30% darker than body color)
        ];

        monkeySprite.forEach((row, i) => {
            row.forEach((pixel, j) => {
                if (pixel !== 0) {  // 0 is transparent
                    ctx.fillStyle = monkeyColors[pixel];
                    ctx.fillRect(x + j, y + i, 1, 1);
                }
            });
        });
    }

    const ws = new WebSocket('ws://localhost:3000');

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      switch (data.type) {
        case 'init':
          myId = data.id;
          terrain = data.terrain;
          data.players.forEach(player => {
            players.set(player.id, player);
          });
          const myPlayer = players.get(myId);
          if (myPlayer) {
            viewportX = myPlayer.x - canvas.width / 2;
            viewportY = myPlayer.y - canvas.height / 2;
          }
          break;

        case 'playerJoin':
          players.set(data.id, {
            x: data.x,
            y: data.y,
            color: data.color,
            direction: data.direction
          });
          break;

        case 'playerMove':
          if (players.has(data.id)) {
            const player = players.get(data.id);
            player.x = data.x;
            player.y = data.y;
            player.direction = data.direction;
            player.moving = data.moving;
          }
          break;

        case 'playerLeave':
          players.delete(data.id);
          break;

        case 'terrainUpdate':
          terrain[data.y][data.x] = data.value;
          break;
      }
    };

    function getTargetBlock(player) {
      const playerBlockX = Math.floor(player.x / GRID_SIZE);
      const playerBlockY = Math.floor(player.y / GRID_SIZE);
      
      switch(player.direction) {
        case 'left':
          return { x: playerBlockX - 1, y: playerBlockY };
        case 'right':
          return { x: playerBlockX + 1, y: playerBlockY };
        case 'up':
          return { x: playerBlockX, y: playerBlockY - 1 };
        case 'down':
          return { x: playerBlockX, y: playerBlockY + 1 };
      }
    }

    // Handle keyboard input
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      keys.add(e.key);
      if (e.key === ' ') { // Space bar to mine
        const myPlayer = players.get(myId);
        if (myPlayer) {
          const targetBlock = getTargetBlock(myPlayer);
          ws.send(JSON.stringify({
            type: 'mine',
            blockX: targetBlock.x,
            blockY: targetBlock.y
          }));
        }
      }
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key));

    function gameLoop(timestamp) {
    // Update animation frame
      if (timestamp - lastAnimationUpdate > ANIMATION_SPEED) {
        animationFrame = (animationFrame + 1) % 2;
        lastAnimationUpdate = timestamp;
      }

      const myPlayer = players.get(myId);
      if (myPlayer) {
        const speed = 4;
        let newX = myPlayer.x;
        let newY = myPlayer.y;
        let moved = false;
        let newDirection = myPlayer.direction;
        
        if (keys.has('ArrowLeft')) {
          newX -= speed;
          newDirection = 'left';
        }
        if (keys.has('ArrowRight')) {
          newX += speed;
          newDirection = 'right';
        }
        if (keys.has('ArrowUp')) {
          newY -= speed;
          newDirection = 'up';
        }
        if (keys.has('ArrowDown')) {
          newY += speed;
          newDirection = 'down';
        }

        // Check collision with terrain
        const blockX = Math.floor(newX / GRID_SIZE);
        const blockY = Math.floor(newY / GRID_SIZE);
        
        if (!terrain[blockY]?.[blockX]) {
          moved = newX !== myPlayer.x || newY !== myPlayer.y;
          myPlayer.x = newX;
          myPlayer.y = newY;
        }

        // Always update direction, even if movement is blocked
        if (newDirection !== myPlayer.direction || moved) {
          myPlayer.direction = newDirection;
          myPlayer.moving = moved;
          ws.send(JSON.stringify({
            type: 'move',
            x: myPlayer.x,
            y: myPlayer.y,
            direction: myPlayer.direction,
            moving: myPlayer.moving
          }));

          viewportX = myPlayer.x - canvas.width / 2;
          viewportY = myPlayer.y - canvas.height / 2;
        }

        positionElement.textContent = `${Math.floor(myPlayer.x / GRID_SIZE)}, ${Math.floor(myPlayer.y / GRID_SIZE)}`;
      }

      // Clear canvas
      ctx.fillStyle = '#B89D81';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw terrain
      const startBlockX = Math.floor(viewportX / GRID_SIZE);
      const startBlockY = Math.floor(viewportY / GRID_SIZE);
      const endBlockX = startBlockX + Math.ceil(canvas.width / GRID_SIZE) + 1;
      const endBlockY = startBlockY + Math.ceil(canvas.height / GRID_SIZE) + 1;

      const pattern = ctx.createPattern(dirtPattern, 'repeat');
      ctx.fillStyle = pattern;

      for (let y = startBlockY; y < endBlockY; y++) {
        for (let x = startBlockX; x < endBlockX; x++) {
          if (terrain[y]?.[x]) {
            const screenX = x * GRID_SIZE - viewportX;
            const screenY = y * GRID_SIZE - viewportY;
            
            // Save context state
            ctx.save();
            // Translate to position and draw pattern
            ctx.translate(screenX, screenY);
            ctx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
            // Restore context state
            ctx.restore();
          }
        }
      }

      // Draw mining target indicator for current player
      if (myPlayer) {
        const targetBlock = getTargetBlock(myPlayer);
        if (terrain[targetBlock.y]?.[targetBlock.x]) {
          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
          ctx.fillRect(
            targetBlock.x * GRID_SIZE - viewportX,
            targetBlock.y * GRID_SIZE - viewportY,
            GRID_SIZE,
            GRID_SIZE
          );
        }
      }

      // Draw players
      players.forEach((player, id) => {
        const screenX = player.x - viewportX - GRID_SIZE/2;
        const screenY = player.y - viewportY - GRID_SIZE/2;
        
        // Only animate if player is moving
        const frame = player.moving ? animationFrame : 0;
        drawMonkeySprite(ctx, screenX, screenY, player.color); // player.color, player.direction, frame
        
        // Draw outline for current player
        if (id === myId) {
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.strokeRect(screenX, screenY, GRID_SIZE, GRID_SIZE);
        }
      });

      playerCountElement.textContent = players.size;

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
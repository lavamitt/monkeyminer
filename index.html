<!DOCTYPE html>
<html lang="en">
<head>
  <title>monkey miner!</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #1a1a1a;
    }
    #game {
      position: absolute;
      top: 0;
      left: 0;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #controls {
      position: fixed;
      bottom: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #topScores {
      position: fixed;
      top: 10px;
      right: 10px;
      color: white;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #inventorySlot {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        border: 2px solid #666;
        background: rgba(0, 0, 0, 0.4);
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script src="monkey.js" type="module"></script>
  <script src="banana.js" type="module"></script>
  <div id="info">
    Players Online: <span id="playerCount">0</span><br>
    Position: <span id="position">0, 0</span><br>
    ID: <span id='monkeyId'>null</span><br>
    Score: <span id="score">0</span>
  </div>
  <div id="controls">
    Arrow keys to move<br>
    Space to mine the highlighted block<br>
    Q to pick up a highlighted banana
  </div>
  <div id="topScores">
    Top Scores:<br>
    <span id="scores"></span>
  </div>
  <canvas id="inventorySlot" width="48" height="48"></canvas>

  <script type="module">
    import { drawMonkeySprite } from './monkey.js';
    import { drawBananaSprite } from './banana.js';

    // SET UP GAME CANVAS
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const playerCountElement = document.getElementById('playerCount');
    const positionElement = document.getElementById('position');
    const scoreElement = document.getElementById('score');
    const topScoresElement = document.getElementById('scores');
    const monkeyIdElement = document.getElementById('monkeyId');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // GAME STATE
    const GRID_SIZE = 32;
    let players = new Map();
    let myId = null;
    let viewportX = 0;
    let viewportY = 0;
    let terrain = [];
    let zones = new Map();
    let animationFrame = 0;
    let lastAnimationUpdate = 0;
    const ANIMATION_SPEED = 150;

    const BLOCK_TYPE = Object.freeze({
      EMPTY: 0,
      DIRT: 1,
      ORE: 2,
      EMPTY_WITH_BANANA: 3,
      ZONE: 4
    });

    // TILE PATTERNS
    function createDirtPattern() {
      const dirtPattern = document.createElement('canvas');
      dirtPattern.width = GRID_SIZE;
      dirtPattern.height = GRID_SIZE;
      const dirtPatternCtx = dirtPattern.getContext('2d');

      // Base brown color
      dirtPatternCtx.fillStyle = '#8B6143';
      dirtPatternCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
      
      // Add texture details
      dirtPatternCtx.fillStyle = '#7B5133';
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 2 + Math.random() * 4;
        dirtPatternCtx.fillRect(x, y, size, size);
      }

      // Add some lighter specs
      dirtPatternCtx.fillStyle = '#9B7153';
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 1 + Math.random() * 3;
        dirtPatternCtx.fillRect(x, y, size, size);
      }

      // Add a subtle grid line
      dirtPatternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      dirtPatternCtx.strokeRect(0, 0, GRID_SIZE, GRID_SIZE);

      return ctx.createPattern(dirtPattern, 'repeat')
    }

    function createOrePattern() {
      const orePattern = document.createElement('canvas');
      orePattern.width = GRID_SIZE;
      orePattern.height = GRID_SIZE;
      const orePatternCtx = orePattern.getContext('2d');

      // Base grey color
      orePatternCtx.fillStyle = '#9AA7AD';
      orePatternCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
      
      // Add texture details
      orePatternCtx.fillStyle = '#818594';
      for (let i = 0; i < 8; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 2 + Math.random() * 4;
        orePatternCtx.fillRect(x, y, size, size);
      }

      // Add some lighter specs
      orePatternCtx.fillStyle = '#B0C4D4';
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * GRID_SIZE;
        const y = Math.random() * GRID_SIZE;
        const size = 1 + Math.random() * 3;
        orePatternCtx.fillRect(x, y, size, size);
      }

      // Add a subtle grid line
      orePatternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      orePatternCtx.strokeRect(0, 0, GRID_SIZE, GRID_SIZE);

      return ctx.createPattern(orePattern, 'repeat');
    }

    // Create patterns for each block type
    const patterns = {
        [BLOCK_TYPE.DIRT]: createDirtPattern(),
        [BLOCK_TYPE.ORE]: createOrePattern(),
    };

    const ANIMATION_FRAMES = 8;  // Number of frames in the animation
    const zonePatternCache = {
        completed: new Array(ANIMATION_FRAMES),
        incomplete: new Array(ANIMATION_FRAMES)
    };

    function createZonePatterns() {
      // Create patterns for each animation frame
      for (let frame = 0; frame < ANIMATION_FRAMES; frame++) {
        // Create completed pattern
        const completedCanvas = document.createElement('canvas');
        completedCanvas.width = GRID_SIZE;
        completedCanvas.height = GRID_SIZE;
        const completedCtx = completedCanvas.getContext('2d');
        
        // Base color and lines (static part)
        completedCtx.fillStyle = '#2eb82e';
        completedCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
        completedCtx.strokeStyle = '#1a661a';
        completedCtx.lineWidth = 1;
        
        completedCtx.beginPath();
        completedCtx.moveTo(0, GRID_SIZE/2);
        completedCtx.quadraticCurveTo(GRID_SIZE/2, 0, GRID_SIZE, GRID_SIZE/2);
        completedCtx.stroke();
        
        completedCtx.beginPath();
        completedCtx.moveTo(GRID_SIZE/2, 0);
        completedCtx.quadraticCurveTo(GRID_SIZE, GRID_SIZE/2, GRID_SIZE/2, GRID_SIZE);
        completedCtx.stroke();
        
        // Animated sparkles
        completedCtx.fillStyle = '#4dff4d';
        // Use frame number to offset sparkle positions
        for (let i = 0; i < 4; i++) {
            const angle = (frame / ANIMATION_FRAMES * Math.PI * 2) + (i * Math.PI / 2);
            const radius = GRID_SIZE / 4;
            const x = GRID_SIZE/2 + Math.cos(angle) * radius;
            const y = GRID_SIZE/2 + Math.sin(angle) * radius;
            completedCtx.beginPath();
            completedCtx.arc(x, y, 2, 0, Math.PI * 2);
            completedCtx.fill();
        }
        
        // Create incomplete pattern
        const incompleteCanvas = document.createElement('canvas');
        incompleteCanvas.width = GRID_SIZE;
        incompleteCanvas.height = GRID_SIZE;
        const incompleteCtx = incompleteCanvas.getContext('2d');
        
        // Base color and lines (static part)
        incompleteCtx.fillStyle = '#cc3300';
        incompleteCtx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
        incompleteCtx.strokeStyle = '#801a00';
        incompleteCtx.lineWidth = 1;
        
        incompleteCtx.beginPath();
        incompleteCtx.moveTo(0, GRID_SIZE/2);
        incompleteCtx.quadraticCurveTo(GRID_SIZE/2, 0, GRID_SIZE, GRID_SIZE/2);
        incompleteCtx.stroke();
        
        incompleteCtx.beginPath();
        incompleteCtx.moveTo(GRID_SIZE/2, 0);
        incompleteCtx.quadraticCurveTo(GRID_SIZE, GRID_SIZE/2, GRID_SIZE/2, GRID_SIZE);
        incompleteCtx.stroke();
        
        // Animated sparkles
        incompleteCtx.fillStyle = '#ff6666';
        for (let i = 0; i < 4; i++) {
            const angle = (frame / ANIMATION_FRAMES * Math.PI * 2) + (i * Math.PI / 2);
            const radius = GRID_SIZE / 4;
            const x = GRID_SIZE/2 + Math.cos(angle) * radius;
            const y = GRID_SIZE/2 + Math.sin(angle) * radius;
            incompleteCtx.beginPath();
            incompleteCtx.arc(x, y, 2, 0, Math.PI * 2);
            incompleteCtx.fill();
        }
        
        // Cache the patterns
        zonePatternCache.completed[frame] = ctx.createPattern(completedCanvas, 'repeat');
        zonePatternCache.incomplete[frame] = ctx.createPattern(incompleteCanvas, 'repeat');
      }
    }

    let lastZoneAnimationUpdate = 0;
    let currentZoneFrame = 0;
    const ZONE_ANIMATION_SPEED = 100;

    createZonePatterns();

    // SET UP WEBSOCKET
    // 13.59.50.220
    const ws = new WebSocket('ws://13.59.50.220:3000');

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      switch (data.type) {
        case 'init':
          myId = data.id;
          terrain = data.terrain;
          data.zones.forEach(zone => {
            zones.set(zone.key, zone)
          })
          data.players.forEach(player => {
            players.set(player.id, player);
          });
          const myPlayer = players.get(myId);
          if (myPlayer) {
            viewportX = myPlayer.x - canvas.width / 2;
            viewportY = myPlayer.y - canvas.height / 2;
          }

          monkeyIdElement.textContent = "monkey_" + myPlayer.id;
          break;

        case 'playerJoin':
          players.set(data.id, data.player);
          break;

        case 'playerMove':
          if (players.has(data.id) && data.id !== myId) {
            const player = players.get(data.id);
            player.x = data.x;
            player.y = data.y;
            player.direction = data.direction;
            player.moving = data.moving;
          }
          break;

        case 'scoreUpdate':
          players.get(data.id).score = data.value
          break;

        case 'playerLeave':
          players.delete(data.id);
          break;
        
        case 'inventoryUpdate':
          players.get(data.id).inventory = data.value;
          break;

        case 'terrainUpdate':
          terrain[data.y][data.x] = data.value;
          break;

        case 'zoneUpdate':
          zones.set(data.key, data.zone);
          break;
      }
    };

    function getTargetBlock(player) {
      const playerBlockX = Math.floor(player.x / GRID_SIZE);
      const playerBlockY = Math.floor(player.y / GRID_SIZE);
      
      switch(player.direction) {
        case 'left':
          return { x: playerBlockX - 1, y: playerBlockY };
        case 'right':
          return { x: playerBlockX + 1, y: playerBlockY };
        case 'up':
          return { x: playerBlockX, y: playerBlockY - 1 };
        case 'down':
          return { x: playerBlockX, y: playerBlockY + 1 };
      }
    }

    // Handle keyboard input
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      keys.add(e.key);
      if (e.key === ' ') { // Space bar to mine
        const myPlayer = players.get(myId);
        if (myPlayer) {
          const targetBlock = getTargetBlock(myPlayer);
          ws.send(JSON.stringify({
            type: 'mine',
            blockX: targetBlock.x,
            blockY: targetBlock.y
          }));
        }
      }

      if (e.key === "q") {
        const myPlayer = players.get(myId);
        if (myPlayer) {
          const targetBlock = getTargetBlock(myPlayer);
          ws.send(JSON.stringify({
            type: 'pickup',
            blockX: targetBlock.x,
            blockY: targetBlock.y
          }));
        }
      }
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key));

    function gameLoop(timestamp) {
      if (timestamp - lastAnimationUpdate > ANIMATION_SPEED) {
        animationFrame = (animationFrame + 1) % 2;
        lastAnimationUpdate = timestamp;
      }

      if (timestamp - lastZoneAnimationUpdate > ZONE_ANIMATION_SPEED) {
        currentZoneFrame = (currentZoneFrame + 1) % ANIMATION_FRAMES;
        lastZoneAnimationUpdate = timestamp;
      }

      const myPlayer = players.get(myId);
      if (myPlayer) {
        const speed = 6;
        let newX = myPlayer.x;
        let newY = myPlayer.y;
        let moved = false;
        let newDirection = myPlayer.direction;
        
        if (keys.has('ArrowLeft')) {
          newX -= speed;
          newDirection = 'left';
        }
        if (keys.has('ArrowRight')) {
          newX += speed;
          newDirection = 'right';
        }
        if (keys.has('ArrowUp')) {
          newY -= speed;
          newDirection = 'up';
        }
        if (keys.has('ArrowDown')) {
          newY += speed;
          newDirection = 'down';
        }

        // Check collision with terrain
        const blockX = Math.floor(newX / GRID_SIZE);
        const blockY = Math.floor(newY / GRID_SIZE);
        
        if (terrain[blockY]?.[blockX] == BLOCK_TYPE.EMPTY || terrain[blockY]?.[blockX] == BLOCK_TYPE.EMPTY_WITH_BANANA || terrain[blockY]?.[blockX] == BLOCK_TYPE.ZONE) {
          moved = newX !== myPlayer.x || newY !== myPlayer.y;
          myPlayer.x = newX;
          myPlayer.y = newY;
        }

        // Always update direction, even if movement is blocked
        if (newDirection !== myPlayer.direction || moved) {
          myPlayer.direction = newDirection;
          myPlayer.moving = moved;
          ws.send(JSON.stringify({
            type: 'move',
            x: myPlayer.x,
            y: myPlayer.y,
            direction: myPlayer.direction,
            moving: myPlayer.moving
          }));

          viewportX = myPlayer.x - canvas.width / 2;
          viewportY = myPlayer.y - canvas.height / 2;
        }

        myPlayer.moving = moved;

        positionElement.textContent = `${Math.floor(myPlayer.x / GRID_SIZE)}, ${Math.floor(myPlayer.y / GRID_SIZE)}`;
      }

      // Clear canvas
      ctx.fillStyle = '#B89D81';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw terrain
      const startBlockX = Math.floor(viewportX / GRID_SIZE);
      const startBlockY = Math.floor(viewportY / GRID_SIZE);
      const endBlockX = startBlockX + Math.ceil(canvas.width / GRID_SIZE) + 1;
      const endBlockY = startBlockY + Math.ceil(canvas.height / GRID_SIZE) + 1;

      for (let y = startBlockY; y < endBlockY; y++) {
        for (let x = startBlockX; x < endBlockX; x++) {
          let block = terrain[y]?.[x];
          if (block !== BLOCK_TYPE.EMPTY) {
            const screenX = x * GRID_SIZE - viewportX;
            const screenY = y * GRID_SIZE - viewportY;

            if (block === BLOCK_TYPE.ZONE) {
                // Find which zone this block belongs to
                for (let [coords, zone] of zones) {
                    const [zx, zy] = coords.split(',').map(Number);
                    if (x >= zx && x < zx + zone.width && 
                        y >= zy && y < zy + zone.height) {
                        // Draw zone pattern
                        ctx.fillStyle = zone.completed ? 
                          zonePatternCache.completed[currentZoneFrame] : 
                          zonePatternCache.incomplete[currentZoneFrame];
                        ctx.fillRect(screenX, screenY, GRID_SIZE, GRID_SIZE);
                        
                        // If this is the center block of the zone, draw the requirement text
                        const centerX = Math.floor(zx + zone.width/2) === x;
                        const centerY = Math.floor(zy + zone.height/2) === y;
                        if (centerX && centerY && !zone.completed) {
                            // Draw requirement text
                            ctx.save();
                            ctx.fillStyle = 'white';
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 3;
                            ctx.font = 'bold 20px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const text = `${zone.currentMonkeys.length}/${zone.requiredMonkeys}`;
                            const textX = screenX + GRID_SIZE/2;
                            const textY = screenY + GRID_SIZE/2;
                            // Draw text stroke
                            ctx.strokeText(text, textX, textY);
                            // Draw text fill
                            ctx.fillText(text, textX, textY);
                            ctx.restore();
                        }
                        break;
                    }
                }
            } else if (block === BLOCK_TYPE.EMPTY_WITH_BANANA) {
              drawBananaSprite(ctx, screenX, screenY);
            } else {
              // Get pattern based on block type
              const pattern = patterns[block];
              if (pattern) {
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.fillStyle = pattern;
                ctx.fillRect(0, 0, GRID_SIZE, GRID_SIZE);
                ctx.restore();
              }
            }
         }
        }
      }

      // Draw mining target indicator for current player
      if (myPlayer) {
        const targetBlock = getTargetBlock(myPlayer);
        if (terrain[targetBlock.y]?.[targetBlock.x] !== BLOCK_TYPE.EMPTY) {
          ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
          ctx.fillRect(
            targetBlock.x * GRID_SIZE - viewportX,
            targetBlock.y * GRID_SIZE - viewportY,
            GRID_SIZE,
            GRID_SIZE
          );
        }
      }

      // Draw players
      players.forEach((player, id) => {
        const screenX = player.x - viewportX - GRID_SIZE/2;
        const screenY = player.y - viewportY - GRID_SIZE/2;
        
        // Only animate if player is moving
        const frame = player.moving ? animationFrame : 0;
        drawMonkeySprite(ctx, screenX, screenY, player.color, player.direction, frame);
        
        // Draw outline for current player
        if (id === myId) {
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.strokeRect(screenX, screenY, GRID_SIZE, GRID_SIZE);
        }
      });

      const inventoryCanvas = document.getElementById('inventorySlot');
      const inventoryCtx = inventoryCanvas.getContext('2d');

      inventoryCtx.clearRect(0, 0, 48, 48);
      inventoryCtx.fillStyle = 'rgba(68, 68, 68, 0.4)';
      inventoryCtx.fillRect(0, 0, 48, 48);
      inventoryCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      inventoryCtx.strokeRect(0, 0, 48, 48);

      if (myPlayer && myPlayer.inventory.length > 0) {
          drawBananaSprite(inventoryCtx, 8, 8);
      }

      playerCountElement.textContent = players.size;
      if (myPlayer) {
        scoreElement.textContent = myPlayer.score;
      }
      const current_players = Array.from(players.values());
      current_players.sort((a, b) => b.score - a.score);
      topScoresElement.innerHTML = current_players.map((player) => "monkey_" + player.id + ": " + player.score).join('<br>');

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>